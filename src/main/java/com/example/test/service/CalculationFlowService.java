package com.example.test.service;

import reactor.core.publisher.Flux;

/**
 * Интерфейс для сервиса, который создает и управляет потоками вычислений.
 *
 * SOLID (O): Принцип открытости/закрытости.
 * Систему можно расширить новыми реализациями (например, другим способом организации потоков),
 * не изменяя код, который использует этот интерфейс (например, CalculatorController).
 *
 * SOLID (I): Принцип разделения интерфейса.
 * Интерфейс сфокусирован на одной задаче - создании потоков вычислений. Клиенты не вынуждены
 * зависеть от методов, которые им не нужны.
 *
 * ООП: Принцип Абстракции.
 * Подобно CalculationService, этот интерфейс определяет контракт для создания потоков.
 * Контроллер, который его использует, не знает о деталях реализации (например, об использовании
 * Flux.merge или Mono.zip). Он просто вызывает нужный метод, работая с абстракцией.
 */
public interface CalculationFlowService {

    /**
     * Создает упорядоченный (синхронизированный) поток результатов вычислений.
     * В этом режиме результат для каждой итерации отправляется только после того,
     * как обе функции завершат вычисление.
     *
     * @param count Количество итераций.
     * @return Flux, выдающий строки в формате CSV для упорядоченного вывода.
     */
    Flux<String> createOrderedFlow(int count);

    /**
     * Создает неупорядоченный (асинхронный) поток результатов вычислений.
     * В этом режиме результаты отправляются по мере их готовности, без ожидания
     * завершения другой функции.
     *
     * @param count Количество итераций.
     * @return Flux, выдающий строки в формате CSV для неупорядоченного вывода.
     */
    Flux<String> createUnorderedFlow(int count);
}
